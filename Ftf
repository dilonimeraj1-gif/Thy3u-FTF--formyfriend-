local Luna = loadstring(game:HttpGet("https://raw.nebulasoftworks.xyz/luna", true))()

getgenv().Genv = getgenv().Genv or {}
Genv.SHub = Genv.SHub or {}
Genv.SHub.Notify = Genv.SHub.Notify or {}
Genv.SHub.Anti = Genv.SHub.Anti or {}
Genv.SHub.Toggle = Genv.SHub.Toggle or {}
Genv.SHub.TaskSignal = Genv.SHub.TaskSignal or {}

local SPlayers = game:GetService("Players")
local SRunService = game:GetService("RunService")
local SReplicatedStorage = game:GetService("ReplicatedStorage")
local LP = SPlayers.LocalPlayer


local Window = Luna:CreateWindow({
    Name = "Thy3u FTF", -- This Is Title Of Your Window
    Subtitle = "Flee The Facility Script.", -- A Gray Subtitle next To the main title.
    LogoID = "82795327169782", -- The Asset ID of your logo. Set to nil if you do not have a logo for Luna to use.
    LoadingEnabled = true, -- Whether to enable the loading animation. Set to false if you do not want the loading screen or have your own custom one.
    LoadingTitle = "Loading Thy3u..", -- Header for loading screen
    LoadingSubtitle = "Wait a second..", -- Subtitle for loading screen

    ConfigSettings = {
        RootFolder = nil, -- The Root Folder Is Only If You Have A Hub With Multiple Game Scripts and u may remove it. DO NOT ADD A SLASH
        ConfigFolder = "Big Hub" -- The Name Of The Folder Where Luna Will Store Configs For This Script. DO NOT ADD A SLASH
    },

    KeySystem = false, -- As Of Beta 6, Luna Has officially Implemented A Key System!
    KeySettings = {
        Title = "Luna Example Key",
        Subtitle = "Key System",
        Note = "Best Key System Ever! Also, Please Use A HWID Keysystem like Pelican, Luarmor etc. that provide key strings based on your HWID since putting a simple string is very easy to bypass",
        SaveInRoot = false, -- Enabling will save the key in your RootFolder (YOU MUST HAVE ONE BEFORE ENABLING THIS OPTION)
        SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
        Key = {"Example Key"}, -- List of keys that will be accepted by the system, please use a system like Pelican or Luarmor that provide key strings based on your HWID since putting a simple string is very easy to bypass
        SecondAction = {
            Enabled = true, -- Set to false if you do not want a second action,
            Type = "Link", -- Link / Discord.
            Parameter = "" -- If Type is Discord, then put your invite link (DO NOT PUT DISCORD.GG/). Else, put the full link of your key system here.
        }
    }
})

Window:CreateHomeTab({
    SupportedExecutors = {}, -- A Table Of Executors Your Script Supports. Add strings of the executor names for each executor.
    DiscordInvite = "1234", -- The Discord Invite Link. Do Not Include discord.gg/ | Only Include the code.
    Icon = 1, -- By Default, The Icon Is The Home Icon. If You would like to change it to dashboard, replace the interger with 2
})

local MainTab = Window:CreateTab({
    Name = "InGame",
    Icon = "kitchen",
    ImageSource = "Material",
    ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local BeastTab = Window:CreateTab({
    Name = "Beast",
    Icon = "directions_run",
    ImageSource = "Material",
    ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local TrollTab = Window:CreateTab({
    Name = "Troll",
    Icon = "more_horiz",
    ImageSource = "Material",
    ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local LocalTab = Window:CreateTab({
    Name = "Local Player",
    Icon = "person",
    ImageSource = "Material",
    ShowTitle = true -- This will determine whether the big header text in the tab will show
})

local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local CoreGui = game:GetService("CoreGui")

local playerESPEnabled = false

local function notify(title, text)
    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = 3
    })
end

local function applyHighlight(player)
    if player == Players.LocalPlayer then return end
    local char = player.Character
    if not char or not char:IsA("Model") then return end

    local existingHighlight = CoreGui:FindFirstChild("ESP_" .. player.Name)

    if playerESPEnabled then
        if not existingHighlight then
            local highlight = Instance.new("Highlight")
            highlight.Name = "ESP_" .. player.Name
            highlight.Adornee = char
            highlight.FillColor = Color3.fromRGB(0, 255, 255)
            highlight.OutlineColor = Color3.new(1, 1, 1)
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Parent = CoreGui
        end
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
            humanoid.NameDisplayDistance = math.huge
        end
    else
        if existingHighlight then existingHighlight:Destroy() end
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
            humanoid.NameDisplayDistance = 100 -- default
        end
    end
end


local Button = MainTab:CreateButton({
    Name = "Player Esp",
    Description = nil, -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    Callback = function()
playerESPEnabled = not playerESPEnabled
    notify("Player ESP", playerESPEnabled and "Esp Enabled." or "Esp Disabled.")

    for _, player in ipairs(Players:GetPlayers()) do
        applyHighlight(player)
    end

    Players.PlayerAdded:Connect(function(player)
        player.CharacterAdded:Connect(function()
            if playerESPEnabled then
                task.wait(1)
                applyHighlight(player)
            end
        end)
    end)
    end
})

local Button = MainTab:CreateButton({
    Name = "Computer Esp",
    Description = nil, -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    Callback = function()
computerESPEnabled = not computerESPEnabled
	notify("Computer Esp", computerESPEnabled and "Esp Enabled." or "Esp Disabled.")

	for _, model in ipairs(Workspace:GetDescendants()) do
		if model:IsA("Model") and model.Name == "ComputerTable" then
			local highlight = model:FindFirstChild("ComputerESPHighlight")
			if computerESPEnabled then
				if not highlight then
					local screenColor = Color3.fromRGB(255, 255, 255)
					for _, part in ipairs(model:GetDescendants()) do
						if part:IsA("BasePart") and part.Name == "Part" then
							screenColor = part.Color
							break
						end
					end
					local newHighlight = Instance.new("Highlight")
					newHighlight.Name = "ComputerESPHighlight"
					newHighlight.Adornee = model
					newHighlight.FillColor = screenColor
					newHighlight.OutlineColor = Color3.new(1, 1, 1)
					newHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
					newHighlight.Parent = model
				end
			elseif highlight then
				highlight:Destroy()
			end
		end
	end
    end
})

local Button = MainTab:CreateButton({
    Name = "Exit Door Esp",
    Description = nil, -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    Callback = function()
exitESPEnabled = not exitESPEnabled
	notify("ExitDoor ESP", exitESPEnabled and "Exit Door Enabled" or "Exit Door Disabled")

	for _, model in ipairs(Workspace:GetDescendants()) do
		if model:IsA("Model") and model.Name == "ExitDoor" then
			local light = model:FindFirstChild("Light")
			if light then
				local highlight = light:FindFirstChild("ExitESPHighlight")
				if exitESPEnabled then
					if not highlight then
						local newHighlight = Instance.new("Highlight")
						newHighlight.Name = "ExitESPHighlight"
						newHighlight.Adornee = light
						newHighlight.FillColor = Color3.new(1, 1, 0)
						newHighlight.OutlineTransparency = 1
						newHighlight.FillTransparency = 0.5
						newHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
						newHighlight.Parent = light
					end
				elseif highlight then
					highlight:Destroy()
				end
			end
		end
	end
    end
})

local Button = MainTab:CreateButton({
    Name = "Freeze Pod Esp",
    Description = nil, -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    Callback = function()
computerESPEnabled = not computerESPEnabled
	notify("FreezePod Esp", computerESPEnabled and "Esp Enabled." or "Esp Disabled.")

	for _, model in ipairs(Workspace:GetDescendants()) do
		if model:IsA("Model") and model.Name == "FreezePod" then
			local highlight = model:FindFirstChild("ComputerESPHighlight")
			if computerESPEnabled then
				if not highlight then
					local screenColor = Color3.fromRGB(255, 255, 255)
					for _, part in ipairs(model:GetDescendants()) do
						if part:IsA("BasePart") and part.Name == "Part" then
							screenColor = part.Color
							break
						end
					end
					local newHighlight = Instance.new("Highlight")
					newHighlight.Name = "ComputerESPHighlight"
					newHighlight.Adornee = model
					newHighlight.FillColor = screenColor
					newHighlight.OutlineColor = Color3.new(1, 1, 1)
					newHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
					newHighlight.Parent = model
				end
			elseif highlight then
				highlight:Destroy()
			end
		end
	end
    end
})

MainTab:CreateDivider()

local Button = MainTab:CreateButton({
    Name = "Auto Hack",
    Description = nil, -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    Callback = function()
       _G.AutomaticHackingEnabled = not _G.AutomaticHackingEnabled

game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "Auto Hacking";
    Text = _G.AutomaticHackingEnabled and "Auto Hacking Enabled." or "Auto Hacking Disabled.";
    Duration = 3;
})

while _G.AutomaticHackingEnabled do
    wait(0.1)
    local args = {
        "SetPlayerMinigameResult",
        true
    }
    game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
end
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

local speaker = Players.LocalPlayer
local thirdPersonEnabled = false
local cameraLoop = nil

local function notify(title, text)
	StarterGui:SetCore("SendNotification", {
		Title = title,
		Text = text,
		Duration = 3
	})
end

local Button = LocalTab:CreateButton({
    Name = "Third-Person",
    Description = "Use when beast.", -- Creates A Description For Users to know what the button does (looks bad if you use it all the time),
    Callback = function()
thirdPersonEnabled = not thirdPersonEnabled

	if thirdPersonEnabled then
		notify("Third Person", "Enabled.")
		speaker.CameraMode = Enum.CameraMode.Classic
		cameraLoop = RunService.RenderStepped:Connect(function()
			if speaker.CameraMode ~= Enum.CameraMode.Classic then
				speaker.CameraMode = Enum.CameraMode.Classic
			end
		end)
	else
		notify("Third Person", "Disabled.")
		if cameraLoop then
			cameraLoop:Disconnect()
			cameraLoop = nil
		end
	end
    end
})

local function GetCurrentBeastHEvent(needed)
    for _, p in pairs(SPlayers:GetPlayers()) do
        if p ~= LP and p.Character then
            local c = p.Character
            if c:FindFirstChild "Hammer" then
                return not needed and c:FindFirstChild("HammerEvent", true) or c
            end
        end
    end
end
local function GetCurrentBeastPEvent(needed)
    for _, p in pairs(SPlayers:GetPlayers()) do
        if p ~= LP and p.Character then
            local c = p.Character
            if c:FindFirstChild "BeastPowers" then
                return not needed and c:FindFirstChild("PowersEvent", true) or c
            end
        end
    end
end

local Toggle = TrollTab:CreateToggle({
    Name = "Make Beast Walk Slowly",
    Description = "Makes beast walk slow.",
    CurrentValue = false,
    Callback = function(Value)
Genv.SHub.Toggle.Rg_SlowBt = Value
 while Genv.SHub.Toggle.Rg_SlowBt and task.wait(0.05) do
    local event = GetCurrentBeastPEvent()
    if event then event:FireServer("Jumped") end
 end
    end
}, "Toggle") -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps

local Toggle = TrollTab:CreateToggle({
    Name = "Untie Player",
    Description = "Makes beast untie player instanly.",
    CurrentValue = false,
    Callback = function(Value)
      Genv.SHub.Toggle.Rg_distieBt = Value
 while Genv.SHub.Toggle.Rg_distieBt and task.wait(0.05) do
    local event = GetCurrentBeastHEvent()
    if event then event:FireServer("HammerClick", true) end
 end
    end
}, "Toggle") -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps

local Toggle = TrollTab:CreateToggle({
Name = "Force Beast Ability",
Description = "Forces Beast's Ability (they cant use it.)",
CurrentValue = false,
Callback = function(Value)
Genv.SHub.Toggle.Rg_AbiliBt = Value
while Genv.SHub.Toggle.Rg_AbiliBt and task.wait(0.05) do
local event = GetCurrentBeastPEvent()
if event then event:FireServer("Input") end
end
end
}, "Toggle") -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps

local Slider = BeastTab:CreateSlider({
    Name = "Hit Aura Range",
    Range = {0, 200}, -- The Minimum And Maximum Values Respectively
    Increment = 5, -- Basically The Changing Value/Rounding Off
    CurrentValue = 20, -- The Starting Value
    Callback = function(Value)
 Genv.SHub.HitAuraRange=ToNumV(Value)
    end
}, "Slider") -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps

local Toggle = BeastTab:CreateToggle({
    Name = "Hit Aura",
    Description = "Hits Very Far Away.",
    CurrentValue = false,
    Callback = function(Value)
 Genv.SHub.Toggle.HitAura = Value
 while Genv.SHub.Toggle.HitAura and task.wait(0.15) do
    local LHammerEvent = LPC:FindFirstChild("HammerEvent", true)
    for _, p in pairs(SPlayers:GetPlayers()) do
    if p ~= LP and not IsWhilstPlayer(p.Name) then
    local Stats = p:FindFirstChild("TempPlayerStatsModule")
    if not Stats then continue end
    local PisRagdoll, PisCaptured = Stats:FindFirstChild("Ragdoll"), Stats:FindFirstChild("Captured")
    if not (PisRagdoll and PisCaptured) then continue end
        if not (PisRagdoll.Value or PisCaptured.Value) and p.Character then
                local root = GetRootChar(p.Character)
                if root and LPC and LPR and LHammerEvent then
                    if (root.Position - LPR.Position).Magnitude <= Genv.SHub.HitAuraRange then
                    LHammerEvent:FireServer("HammerHit", root)
                end
            end
        end
     end
   end
    end
}, "Toggle") -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps

local Slider = BeastTab:CreateSlider({
    Name = "Auto Tie Range",
    Range = {0, 200}, -- The Minimum And Maximum Values Respectively
    Increment = 5, -- Basically The Changing Value/Rounding Off
    CurrentValue = 20, -- The Starting Value
    Callback = function(Value)
Genv.SHub.TiePlayerRange=ToNumV(Value)
    end
}, "Slider") -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps

local Toggle = BeastTab:CreateToggle({
    Name = "Auto Tie",
    Description = nil,
    CurrentValue = false,
    Callback = function(Value)
Genv.SHub.Toggle.AutoTie = Value
 while Genv.SHub.Toggle.AutoTie and task.wait(0.15) do
    local LHammerEvent = LPC:FindFirstChild("HammerEvent", true)
    for _, p in pairs(SPlayers:GetPlayers()) do
    if p ~= LP and not IsWhilstPlayer(p.Name) then
    local Stats = p:FindFirstChild("TempPlayerStatsModule")
    if not Stats then continue end
    local PisRagdoll, PisCaptured = Stats:FindFirstChild("Ragdoll"), Stats:FindFirstChild("Captured")
    if not (PisRagdoll and PisCaptured) then continue end
        if (PisRagdoll.Value and not PisCaptured.Value) and p.Character then
                local root = GetRootChar(p.Character)
                if root and LPC and LPR and LHammerEvent then
                    if (root.Position - LPR.Position).Magnitude <= Genv.SHub.TiePlayerRange then
                    local pos = (c_type("Vector3", root.Position, true) and root.Position) or Vector3.zero
                    LHammerEvent:FireServer("HammerTieUp", root, pos)
                end
            end
        end
     end
   end
 end
    end
}, "Toggle") -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
